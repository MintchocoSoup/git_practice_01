#1. 리다이렉션
  * 표준 스트림이란?
    - 파일을 읽고 쓰는 과정처럼 데이터를 입출력하는 것 (유닉스의 특징)
    - 데이터가 연속적으로 흐른다는 특징
    - 키보드 -> 운영체제 -> 디스플레이
      - stdin: #0
      - stdout: #1
      - stderr: #2
      - out/ err : 다른 방식으로(루트로) 출력된다

  * 리다이렉션이란?
    - 입출력 방향을 다른 곳으로 바꾼
    - 키보드에서 입력받지 않고 파일에서 받는 것
    - 디스플레이 -> 파일로 쓰는
      ex) ls -l > 파일로 저장한다. 
    - 셸의 역할 중 하나 (OS와 파일을 연결하는 작업)

    1) 출력 리다이렉션
      - 출력 내용을 표준 출력이 아닌 파일로 보내 저장하는 것
      - syntax: 명령 > 파일이름 
        ex) grep Perl animals.txt > Perl.txt

        # cat
          - cnocatenate: 연속으로 이어 붙인다
          - cat <파일이름1, 2, 3, ...> ; cat grades,letters
            - 파일 1 + 2 + 3 ...
            - 파일 1 2
          - 하나 이상의 파일을 여러 종류의 파일과 연결할 때 사용
            - 파일 복사, 병합, 
            - 추가: >> ; cat grades >> letters
    2) 입력 리다이렉션
      - 명령 < 파일
        - wc animals.txt: 프로그램이 파일의 존재를 알고 있음
        - wc < animals.txt: 리다이렉션을 통해 프로그램이 파일의 존재를 알지 못함
    3) 리다이렉션이 불가능한 출력
      - stderr는 리다이렉션이 불가능하다
        - 단, '2>'를 사용하면 리다이렉션이 가능 (2; stderr는 #2)
        - 2>>: 이어쓰기 (line2가 이미 존재할 때)
      - 표준 출력과 오류를 함께 리다이렉션 하려면?: &>
        - Q. 존재하는 파일과 존재하지 않는 파일을 모두 읽어서 새로운 파일을 만들자. 
            line1.txt non.txt -> line2.txt
            - 모두 리다이렉션
            A. $ cat line1.txt non.txt &> line2.txt
    4) 입출력을 동시에
      - 명령 < 입력파일 > 출력파일
        - Q. animals.txt에서 Perl이 있는 라인의 글자(char)수를 세고 결과를 파일로 (result). 입력도 동시에 리다이렉션.
        A. $ grep Perl < animals.txt | wc -c > result.txt 

  - ls, head, echo, cat 차이 인지하기

#2. Escape Leters
  - 특정 문자가 가지고 있는 기능을 차단하게 해주는 기능
    ex) \n, \t -> \\n, \\t
  - \: 역슬래시, 백슬래시
  - $HOME을 그대로 쓰고 싶을 때: \$HOME

  1) ''
    - 제일 강력함
    - 안에 있는 모든 기능을 해제함
    - ex) '$HOME' -> $HOME
  2) ""
    - 일부 기능은 해제하지 않는다.
    - ex) "$HOME" -> /home/runnter
  3) \
    - 일부분을 지정해서 기능 해제 (문자 그대로 읽게 함)
    - 큰 따옴표 안에 큰 따옴표를 사용하려면?
      - "home sweet \"HOME\""
    - 명령 줄 바꿔쓰기 할 때 많이 사용됨 head \ (줄바꿈) grades
    - 별명 무효화
      - alias grep="grep -w" 
        \grep하면 grep -w가 아닌 grep이 실행됨. 

 #3. 검색 경로
  - /usr/bin
  - $PATH -> 검색 경로
   Q. :을 기준으로 개행해서 출력
    - tr <A> <B> : A를 B로 변경함
      A: echo $PATH | tr : "\n"
  - 우리가 사용하는 프로그램이 저장되어 있는 경로
  - 셸이 검색 경로를 순차적으로 순회하며 프로그램을 가져온다. 
  - 검색경로 확인 명령: which, type
    1) which
      ex) which ls -> ls가 있는 경로를 출력
    2) type
      ex) type ls -> ls가 어떻게 alias 되었는지도 보여준다
      - 검색경로 뿐만아니라 더 넓은 범위에서 경로를 조회 (별명까지)
      - 별명이 검색경로를 우선한다. 

#4. 초기화파일
  - shell environment
  - 초기화파일
  - 'ls -a $HOME' # -a: 숨겨진 파일까지 모두 출력
  - $HOME/.bashrc
    - vi로 파일 열기 -> 수정 -> 적용
    - source
  - 사용자가 자주 사용하는 환경설정을 저장하여 항상 셸을 켤 때마다 적용되도록 한다. 

CH.03
#5. 명령 히스토리
  - command history
  - 우리가 커맨드라인에 입력한 명령들을 셸이 저장해서 가지고 있음
  - 히스토리를 사용해서 이전 명령을 불러와 재사용 가능

  1) gltmxhfl duffka
    - $ history
    - LIFO (Last In First Out)
    - $ history 10 (마지막부터 10개)
    Q. 히스토리를 가장 처음부터 10개 출력하기
      : history | head | less
    Q. 전체 히스토리에서 echo만 출력하기
      : history | grep echo
    - history -c : 히스토리 삭제
    - $HISTSIZE: 히스토리 사이즈. 변경 가능. default=1000. -1로 설정하면 무한대.
    - 같은 명령을 연달아 사용하면, history에 어떻게 남을까?
      - $HISTCONTROL: default=ignoredups; 같은 명령어는 한 번만 저장
    - 모든 명령 히스토리는 $HISTFILE에 저장됨

  2) 재사용
    1. 커서링
      - 위아래 키를 사용하여 히스토리 열람
      - 간단, 느림
      - 쓴지 얼마 안된 명령일 경우에 자주 사용
      - 최근 입력한 명령부터 불러옴
    2. 히스토리 확장
      - 특별한 표현식을 활용하는 방법
      - 명령을 가져오고 자동으로 실행까지 함
      - !!: 이전 명령
      - !<명령어>: 가장 마지막에 한 특정 명령 가져와서 실행
      - !<히스토리 번호>: 해당 히스토리 번호의 명령어를 가져와서 실행
        - 음수도 가능 (뒤에서 셈)
      - 쉽지만 실행까지 되기에 주의
        - :p ex) !!:p / !<명령어>:p / !<히스토리 번호>:p : 해당 명령의 이름만 보여줌
        Q. 이전 명령의 단어(word)수 세기 (표현식 활용)
          : !! | wc -w (:p는 필요없음)
          - stdout으로 활용 가능
      - !$ : 이전 명령의 마지막 내용(인수)
        ex) rm !$
        - alias rm-'rm -i' : 삭제하기 전에 확인하라
      - !* : 내용이 2개 이상일 경우 매칭
    3. 증분 검색
      - ctrl + r로 검색해서 enter하면 해당 명령 실행
      - 탈출: esc / ^C / ctrl + j

SUMMARY
  - 명령행 편집을 효율적으로 해보자